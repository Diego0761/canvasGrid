<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Canvas Grid</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }

      .info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgb(7, 7, 7);
        padding: 5px;
        border-radius: 5px;
        font-family: Arial, san s-serif;
        font-size: 22px;
        display: flex;
        flex-direction: column;
      }

      span {
        color: white;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <div class="info">
      <span id="mouseXY">mouse XY: 0, 0 </span>
      <span id="startXY">start X, Y = 0, 0</span>
      <span id="originPosXY">origin X, Y = 0, 0</span>
      <span id="globalMousePosXY">global Mouse X, Y = 0, 0</span>
    </div>

    <script>
      let originPos = { x: 0, y: 0 }

      let paint = false
      let erase = false

      let lastMouse = { x: 0, y: 0 }

      let globalMousePos = { x: 0, y: 0 }

      let startOrigin = { x: 0, y: 0 }

      let gridSize = 32

      let square = {
        worldX: 1024,
        worldY: 512,
        setChunk(chunk) {
          this.worldX = chunk.x * gridSize
          this.worldY = chunk.y * gridSize
        },
        size: gridSize
      }

      let coloredChunks = [{ x: 20, y: 20 }]

      function paintChunk({ x, y }) {
        const chunk = coloredChunks.some(
          chunk => chunk.x === x && chunk.y === y
        )
        if (!chunk) {
          coloredChunks.push({
            x: x,
            y: y
          })
          console.log('Painted chunk at:', x, y)
          console.log('Colored Chunks:', coloredChunks)
        }
      }

      function getChunkFromWorldPos(x, y) {
        console.log('Get chunk from world pos:', x, y)

        return {
          x: Math.floor(x / gridSize),
          y: Math.floor(y / gridSize)
        }
      }

      function Erase() {
        erase = true

        const chunk = getChunkFromWorldPos(globalMousePos.x, globalMousePos.y)

        if (coloredChunks.some(c => c.x === chunk.x && c.y === chunk.y)) {
          coloredChunks = coloredChunks.filter(
            c => !(c.x === chunk.x && c.y === chunk.y)
          )
          console.log('Erased chunk at:', chunk.x, chunk.y)
          drawGrid()
        }
      }

      square.setChunk({ x: 16, y: 16 })

      let mouseState = 'off'

      let a = { x: 0, y: 0 }

      const canvas = document.getElementById('canvas')
      const ctx = canvas.getContext('2d')

      let startX, startY

      function drawGrid() {
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight

        ctx.clearRect(0, 0, canvas.width, canvas.height)
        ctx.strokeStyle = '#00000033'

        for (chunk in coloredChunks) {
          const c = coloredChunks[chunk]
          ctx.fillRect(
            c.x * gridSize + originPos.x,
            c.y * gridSize + originPos.y,
            gridSize,
            gridSize
          )
        }

        startX = (originPos.x % gridSize) - gridSize
        startY = (originPos.y % gridSize) - gridSize

        for (let x = startX; x <= canvas.width; x += gridSize) {
          ctx.beginPath()
          ctx.moveTo(x, 0)
          ctx.lineTo(x, canvas.height)
          ctx.stroke()
        }

        for (let y = startY; y <= canvas.height; y += gridSize) {
          ctx.beginPath()
          ctx.moveTo(0, y)
          ctx.lineTo(canvas.width, y)
          ctx.stroke()
        }
      }

      // -----

      canvas.addEventListener('mousedown', e => {
        mouseState = 'on'

        if (e.button === 2) {
          erase = true
        }
        paint = true

        console.log('Mouse Down at:', e.clientX, e.clientY)
        lastMouse.x = e.clientX
        lastMouse.y = e.clientY
        startOrigin.x = originPos.x
        startOrigin.y = originPos.y
      })

      canvas.addEventListener('mouseup', e => {
        mouseState = 'off'

        if (e.button === 2 && erase) {
          Erase()
        }

        if (e.button === 0 && paint) {
          paintChunk(getChunkFromWorldPos(globalMousePos.x, globalMousePos.y))
        }

        drawGrid()

        console.log('Mouse Up at:', e.clientX, e.clientY)
        console.log('paint ', paint)
      })

      canvas.addEventListener('mousemove', e => {
        document.getElementById('mouseXY').textContent =
          'mouse XY: ' + e.clientX + ', ' + e.clientY
        document.getElementById('startXY').textContent =
          'start X, Y = ' + startX + ', ' + startY
        document.getElementById('originPosXY').textContent =
          'origin X, Y = ' + originPos.x + ', ' + originPos.y

        if (mouseState === 'off') {
          globalMousePos.x = e.clientX - originPos.x
          globalMousePos.y = e.clientY - originPos.y
        }

        document.getElementById('globalMousePosXY').textContent =
          'global Mouse X, Y = ' + globalMousePos.x + ', ' + globalMousePos.y

        if (mouseState === 'on') {
          const deltaX = e.clientX - lastMouse.x
          const deltaY = e.clientY - lastMouse.y

          //check if mouse moved enough to be considered paining

          // this is causing the grid moving 3 in 3 or so
          // need to fix
          if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3 || e.button != 1) {
            paint = false
            erase = false

            originPos.x += deltaX
            originPos.y += deltaY

            lastMouse.x = e.clientX
            lastMouse.y = e.clientY

            drawGrid()
          }
        }
      })

      canvas.addEventListener('contextmenu', e => {
        e.preventDefault()
      })

      drawGrid()

      window.addEventListener('resize', drawGrid)
    </script>
  </body>
</html>
